package application;

import com.sun.net.httpserver.HttpServer;
import com.sun.net.httpserver.HttpExchange;
import java.io.*;
import java.net.InetSocketAddress;
import java.util.HashMap;
import java.util.Map;
import java.util.ArrayList;
import java.util.List;

/**
 * GameWebServer - Christopher Columbus Adventure Backend
 * Complete HTTP server with embedded WebGameSession
 */
public class GameWebServer {
    
    private static final int PORT = 8000;
    private static Map<String, WebGameSession> gameSessions = new HashMap<>();
    private static int sessionCounter = 0;

    public static void main(String[] args) {
        try {
            HttpServer server = HttpServer.create(new InetSocketAddress("localhost", PORT), 50);
            
            server.createContext("/api/start", GameWebServer::handleStart);
            server.createContext("/api/move", GameWebServer::handleMove);
            server.createContext("/api/state", GameWebServer::handleState);
            server.createContext("/", GameWebServer::handleRoot);
            
            server.setExecutor(null);
            server.start();
            
            System.out.println("    Christopher Columbus - Backend Server ");
            System.out.println("    Server: http://localhost:8000                      ");
            System.out.println("    Server running - Press Ctrl+C to stop              ");
            
            
        } catch (IOException e) {
            System.err.println(" ERROR: " + e.getMessage());
            e.printStackTrace();
        }
    }

    private static void handleRoot(HttpExchange exchange) throws IOException {
        String response = "Christopher Columbus Backend - Server Running";
        exchange.getResponseHeaders().set("Content-Type", "text/plain");
        addCORSHeaders(exchange);
        exchange.sendResponseHeaders(200, response.getBytes().length);
        try (OutputStream os = exchange.getResponseBody()) {
            os.write(response.getBytes());
        }
    }

    private static void handleStart(HttpExchange exchange) throws IOException {
        try {
            String query = exchange.getRequestURI().getQuery();
            String difficulty = "MEDIUM";
            
            if (query != null && query.contains("difficulty=")) {
                difficulty = query.split("=")[1].toUpperCase();
            }
            
            String sessionId = "session_" + (++sessionCounter);
            WebGameSession session = new WebGameSession(sessionId, difficulty);
            gameSessions.put(sessionId, session);
            
            System.out.println(" New game started: " + sessionId + " (" + difficulty + ")");
            
            String response = "{\"sessionId\":\"" + sessionId + "\",\"difficulty\":\"" + difficulty + "\",\"level\":1}";
            sendJSON(exchange, response);
            
        } catch (Exception e) {
            System.err.println(" ERROR in handleStart: " + e.getMessage());
            sendJSON(exchange, "{\"error\":\"Failed to start game\"}");
        }
    }

    private static void handleMove(HttpExchange exchange) throws IOException {
        try {
            String query = exchange.getRequestURI().getQuery();
            String sessionId = "";
            String direction = "";
            
            if (query != null) {
                String[] params = query.split("&");
                for (String param : params) {
                    if (param.startsWith("session=")) {
                        sessionId = param.substring(8);
                    }
                    if (param.startsWith("direction=")) {
                        direction = param.substring(10);
                    }
                }
            }
            
            WebGameSession session = gameSessions.get(sessionId);
            if (session != null) {
                session.moveShip(direction);
            }
            
            sendJSON(exchange, "{\"success\":true}");
            
        } catch (Exception e) {
            System.err.println(" ERROR in handleMove: " + e.getMessage());
            sendJSON(exchange, "{\"error\":\"Move failed\"}");
        }
    }

    private static void handleState(HttpExchange exchange) throws IOException {
        try {
            String query = exchange.getRequestURI().getQuery();
            String sessionId = "";
            
            if (query != null && query.contains("session=")) {
                sessionId = query.split("=")[1];
            }
            
            WebGameSession session = gameSessions.get(sessionId);
            String response;
            
            if (session != null) {
                response = session.getGameState();
            } else {
                response = "{\"error\":\"Session not found\"}";
            }
            
            sendJSON(exchange, response);
            
        } catch (Exception e) {
            System.err.println(" ERROR in handleState: " + e.getMessage());
            sendJSON(exchange, "{\"error\":\"State fetch failed\"}");
        }
    }

    private static void sendJSON(HttpExchange exchange, String json) throws IOException {
        exchange.getResponseHeaders().set("Content-Type", "application/json");
        addCORSHeaders(exchange);
        exchange.sendResponseHeaders(200, json.getBytes().length);
        try (OutputStream os = exchange.getResponseBody()) {
            os.write(json.getBytes());
        }
    }

    private static void addCORSHeaders(HttpExchange exchange) {
        exchange.getResponseHeaders().set("Access-Control-Allow-Origin", "*");
        exchange.getResponseHeaders().set("Access-Control-Allow-Methods", "GET, POST, OPTIONS");
        exchange.getResponseHeaders().set("Access-Control-Allow-Headers", "Content-Type");
    }
}

/**
 * WebGameSession - Game logic inside same file
 */
class WebGameSession {
    
    private String sessionId;
    private String difficulty;
    
    private int shipX = 1;
    private int shipY = 1;
    
    private int treasureX;
    private int treasureY;
    
    private int score = 0;
    private int lives = 3;
    private String status = "PLAYING";
    
    private int[][] grid;
    private static final int DIMENSION = 20;
    
    private List<int[]> pirates = new ArrayList<>();
    private List<int[]> monsters = new ArrayList<>();
    private List<Integer> monsterChaseTimer = new ArrayList<>();

    public WebGameSession(String sessionId, String difficulty) {
        this.sessionId = sessionId;
        this.difficulty = difficulty;
        setLivesByDifficulty();
        initializeGame();
    }

    private void setLivesByDifficulty() {
        switch(difficulty.toUpperCase()) {
            case "EASY": 
                this.lives = 5;
                break;
            case "MEDIUM": 
                this.lives = 3;
                break;
            case "HARD": 
                this.lives = 2;
                break;
            case "SURVIVAL": 
                this.lives = 1;
                break;
        }
    }

    private void initializeGame() {
        grid = new int[DIMENSION][DIMENSION];
        
        int islandCount = 12;
        if (difficulty.equals("HARD")) islandCount = 15;
        if (difficulty.equals("SURVIVAL")) islandCount = 20;
        
        for (int i = 0; i < islandCount; i++) {
            int x = (int)(Math.random() * DIMENSION);
            int y = (int)(Math.random() * DIMENSION);
            if (grid[x][y] == 0 && !(x == 1 && y == 1)) {
                grid[x][y] = 1;
            }
        }
        
        do {
            treasureX = (int)(Math.random() * DIMENSION);
            treasureY = (int)(Math.random() * DIMENSION);
        } while (grid[treasureX][treasureY] == 1);
        
        int pirateCount = 1;
        if (difficulty.equals("MEDIUM")) pirateCount = 2;
        if (difficulty.equals("HARD")) pirateCount = 3;
        if (difficulty.equals("SURVIVAL")) pirateCount = 4;
        
        for (int i = 0; i < pirateCount; i++) {
            int px = (int)(Math.random() * DIMENSION);
            int py = (int)(Math.random() * DIMENSION);
            if (grid[px][py] == 0 && !(px == 1 && py == 1) && 
                !(px == treasureX && py == treasureY)) {
                pirates.add(new int[]{px, py});
            }
        }
        
        int monsterCount = 1;
        if (difficulty.equals("MEDIUM")) monsterCount = 2;
        if (difficulty.equals("HARD")) monsterCount = 3;
        if (difficulty.equals("SURVIVAL")) monsterCount = 4;
        
        for (int i = 0; i < monsterCount; i++) {
            int mx = (int)(Math.random() * DIMENSION);
            int my = (int)(Math.random() * DIMENSION);
            if (grid[mx][my] == 0 && !(mx == 1 && my == 1) && 
                !(mx == treasureX && my == treasureY)) {
                monsters.add(new int[]{mx, my});
                monsterChaseTimer.add(0);
            }
        }
    }

    public void moveShip(String direction) {
        if (status.equals("WIN") || status.equals("LOSE")) {
            return;
        }

        int newX = shipX;
        int newY = shipY;
        
        switch(direction.toLowerCase()) {
            case "up": newY = Math.max(0, newY - 1); break;
            case "down": newY = Math.min(DIMENSION - 1, newY + 1); break;
            case "left": newX = Math.max(0, newX - 1); break;
            case "right": newX = Math.min(DIMENSION - 1, newX + 1); break;
        }
        
        if (grid[newY][newX] != 1) {
            shipX = newX;
            shipY = newY;
            score += 10;
            
            if (shipX == treasureX && shipY == treasureY) {
                status = "WIN";
                score += 1000;
                return;
            }
            
            checkPirateCollision();
            if (status.equals("LOSE")) return;
            checkMonsterCollision();
            if (status.equals("LOSE")) return;
        }
        
        movePirates();
        moveMonsters();
        
        checkPirateCollision();
        checkMonsterCollision();
    }

    private void checkPirateCollision() {
        for (int[] pirate : pirates) {
            if (shipX == pirate[0] && shipY == pirate[1]) {
                lives--;
                score = Math.max(0, score - 100);
                if (lives <= 0) {
                    status = "LOSE";
                } else {
                    shipX = 1;
                    shipY = 1;
                }
                return;
            }
        }
    }

    private void checkMonsterCollision() {
        for (int[] monster : monsters) {
            if (shipX == monster[0] && shipY == monster[1]) {
                lives--;
                score = Math.max(0, score - 100);
                if (lives <= 0) {
                    status = "LOSE";
                } else {
                    shipX = 1;
                    shipY = 1;
                }
                return;
            }
        }
    }

    private void movePirates() {
        for (int[] pirate : pirates) {
            int dx = shipX - pirate[0];
            int dy = shipY - pirate[1];
            
            if (Math.abs(dx) > Math.abs(dy)) {
                if (dx > 0) pirate[0]++;
                else if (dx < 0) pirate[0]--;
            } else if (Math.abs(dy) > 0) {
                if (dy > 0) pirate[1]++;
                else if (dy < 0) pirate[1]--;
            }
            
            pirate[0] = Math.max(0, Math.min(DIMENSION - 1, pirate[0]));
            pirate[1] = Math.max(0, Math.min(DIMENSION - 1, pirate[1]));
        }
    }

    private void moveMonsters() {
        for (int i = 0; i < monsters.size(); i++) {
            int[] monster = monsters.get(i);
            int chaseTime = monsterChaseTimer.get(i);
            
            double distToShip = Math.sqrt(
                Math.pow(monster[0] - shipX, 2) + 
                Math.pow(monster[1] - shipY, 2)
            );
            
            if (distToShip <= 6 && Math.abs(treasureX - shipX) < 5 && 
                Math.abs(treasureY - shipY) < 5) {
                monsterChaseTimer.set(i, 15);
                chaseTime = 15;
            }
            
            if (chaseTime > 0) {
                int dx = shipX - monster[0];
                int dy = shipY - monster[1];
                
                if (Math.abs(dx) > Math.abs(dy)) {
                    if (dx > 0) monster[0]++;
                    else if (dx < 0) monster[0]--;
                } else if (Math.abs(dy) > 0) {
                    if (dy > 0) monster[1]++;
                    else if (dy < 0) monster[1]--;
                }
                
                monsterChaseTimer.set(i, chaseTime - 1);
            } else {
                if (Math.random() < 0.2) {
                    int dir = (int)(Math.random() * 4);
                    switch(dir) {
                        case 0: if (monster[1] > 0) monster[1]--; break;
                        case 1: if (monster[1] < DIMENSION-1) monster[1]++; break;
                        case 2: if (monster[0] > 0) monster[0]--; break;
                        case 3: if (monster[0] < DIMENSION-1) monster[0]++; break;
                    }
                }
            }
            
            monster[0] = Math.max(0, Math.min(DIMENSION - 1, monster[0]));
            monster[1] = Math.max(0, Math.min(DIMENSION - 1, monster[1]));
        }
    }

    public String getGameState() {
        StringBuilder sb = new StringBuilder();
        sb.append("{\"grid\":[");
        
        for (int i = 0; i < DIMENSION; i++) {
            sb.append("[");
            for (int j = 0; j < DIMENSION; j++) {
                if (i == shipY && j == shipX) {
                    sb.append("\"S\"");
                } else if (i == treasureY && j == treasureX) {
                    sb.append("\"T\"");
                } else if (grid[i][j] == 1) {
                    sb.append("\"W\"");
                } else {
                    boolean isPirate = false;
                    boolean isMonster = false;
                    
                    for (int[] pirate : pirates) {
                        if (i == pirate[1] && j == pirate[0]) {
                            isPirate = true;
                            break;
                        }
                    }
                    
                    for (int[] monster : monsters) {
                        if (i == monster[1] && j == monster[0]) {
                            isMonster = true;
                            break;
                        }
                    }
                    
                    if (isPirate) {
                        sb.append("\"P\"");
                    } else if (isMonster) {
                        sb.append("\"M\"");
                    } else {
                        sb.append("\"\"");
                    }
                }
                
                if (j < DIMENSION - 1) sb.append(",");
            }
            sb.append("]");
            if (i < DIMENSION - 1) sb.append(",");
        }
        
        sb.append("],\"status\":\"").append(status).append("\",\"score\":").append(score)
          .append(",\"shipX\":").append(shipX).append(",\"shipY\":").append(shipY)
          .append(",\"treasureX\":").append(treasureX).append(",\"treasureY\":").append(treasureY)
          .append(",\"lives\":").append(lives)
          .append(",\"pirates\":").append(pirates.size())
          .append(",\"monsters\":").append(monsters.size()).append("}");
        
        return sb.toString();
    }

    public int getShipX() { return shipX; }
    public int getShipY() { return shipY; }
    public int getTreasureX() { return treasureX; }
    public int getTreasureY() { return treasureY; }
    public int getScore() { return score; }
    public int getLives() { return lives; }
}